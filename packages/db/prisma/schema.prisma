generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  address   String   @unique
  username  String?
  ensName   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions Session[]
}

model Session {
  id        String   @id
  userId    Int
  token     String   @unique
  expiresAt DateTime
  metadata  Json?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Project {
  id              Int      @id @default(autoincrement())
  name            String
  slug            String   @unique
  description     String?
  ownerAddress    String?
  chainId         Int?
  contractAddress String?
  meta            Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  mintRequests MintRequest[]
  liftUnits    LiftUnit[]
  payments     Payment[]
  paymentConfig ProjectPaymentConfig?
}

model LiftUnit {
  id              Int     @id @default(autoincrement())
  externalId      String? @unique
  tokenId         String? @unique
  contractAddress String?
  chainId         Int?

  // Mint request relation (one-to-one)
  mintRequestId String? @unique
  mintRequest   MintRequest? @relation(fields: [mintRequestId], references: [id])

  status   String   @default("DRAFT")
  quantity Decimal?
  unit     String?

  // Project relation
  projectId Int?
  project   Project? @relation(fields: [projectId], references: [id])

  meta      Json?
  issuedAt  DateTime?
  retiredAt DateTime?
  
  // Verification fields (added by migration)
  verificationMethodId String?
  verifiedAt           DateTime?

  // Events relation
  events LiftUnitEvent[]
  
  // Verification relations
  verificationResults VerificationResult[]
  verificationMethod  VerificationMethod? @relation("VerificationMethodLiftUnits", fields: [verificationMethodId], references: [methodId], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([tokenId])
  @@index([contractAddress])
  @@index([chainId])
}

model LiftUnitEvent {
  id         Int    @id @default(autoincrement())
  liftUnitId Int
  type       String

  txHash      String?
  blockNumber Int?
  logIndex    Int?

  payload Json?
  meta    Json?
  eventAt DateTime @default(now())

  liftUnit LiftUnit @relation(fields: [liftUnitId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([liftUnitId, type, txHash])
  @@index([liftUnitId, type])
  @@index([txHash])
}

model Contract {
  id         Int       @id @default(autoincrement())
  name       String
  symbol     String?
  address    String
  chainId    Int
  type       String
  abi        Json?
  deployedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([address, chainId])
  @@index([chainId, type])
}

// Mint Request - tracks the approval workflow
model MintRequest {
  id          String   @id @default(cuid())
  
  // Request details
  projectId   Int
  project     Project  @relation(fields: [projectId], references: [id])
  
  tokenId     String   // ERC-1155 token ID to mint
  amount      String   // Amount to mint (as string for large numbers)
  recipient   String   // Ethereum address to receive tokens
  
  // Verification data
  verificationData Json? // Ecosystem function measurements, photos, reports
  verificationHash String? // IPFS hash or content hash for verification artifacts
  
  // Request metadata
  title       String
  description String?
  requestedBy String   // Ethereum address of requester
  
  // Approval workflow
  status      MintRequestStatus @default(PENDING)
  
  // Admin actions
  reviewedBy  String?  // Admin who reviewed
  reviewedAt  DateTime?
  approvalNotes String? // Admin comments
  
  // Blockchain execution
  txHash      String?  // Transaction hash when minted
  blockNumber Int?     // Block number of mint transaction
  executedAt  DateTime?
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  events      MintRequestEvent[]
  liftUnit    LiftUnit? // One-to-one: mint request can create one lift unit
  
  @@index([status])
  @@index([projectId])
  @@index([requestedBy])
  @@index([createdAt])
}

// Mint Request Status enum
enum MintRequestStatus {
  PENDING     // Awaiting admin review
  APPROVED    // Approved, ready for minting
  MINTING     // Currently being minted on blockchain
  COMPLETED   // Successfully minted
  REJECTED    // Rejected by admin
  FAILED      // Blockchain minting failed
  CANCELLED   // Cancelled by requester
}

// Mint Request Events - audit trail
model MintRequestEvent {
  id            String     @id @default(cuid())
  
  mintRequestId String
  mintRequest   MintRequest @relation(fields: [mintRequestId], references: [id], onDelete: Cascade)
  
  type          MintRequestEventType
  
  // Event details
  performedBy   String     // Address of who performed the action
  notes         String?    // Additional notes/comments
  metadata      Json?      // Additional event-specific data
  
  // Blockchain data (for minting events)
  txHash        String?
  blockNumber   Int?
  gasUsed       String?
  
  createdAt     DateTime   @default(now())
  
  @@index([mintRequestId])
  @@index([type])
  @@index([createdAt])
}

// Mint Request Event Types
enum MintRequestEventType {
  SUBMITTED   // Request submitted
  REVIEWED    // Admin reviewed (could be approved or rejected)
  APPROVED    // Admin approved
  REJECTED    // Admin rejected
  CANCELLED   // Requester cancelled
  MINT_STARTED // Blockchain minting started
  MINT_COMPLETED // Blockchain minting completed
  MINT_FAILED // Blockchain minting failed
}

// Payment processing and escrow management
model Payment {
  id               String          @id @default(cuid())
  
  // Payment identification
  paymentType      PaymentType
  status           PaymentStatus   @default(PENDING)
  
  // Related entities
  projectId        Int?
  project          Project?        @relation(fields: [projectId], references: [id])
  
  // Payment details
  amount           String          // Amount in payment token (string for precision)
  paymentToken     String          // Contract address of payment token
  chainId          Int
  
  // Payer information
  payerAddress     String          // Address making payment
  payerEmail       String?         // Optional email for notifications
  
  // Recipient information
  recipientAddress String          // Address receiving payment
  
  // Escrow contract information
  escrowContract   String?         // Address of escrow contract
  escrowConfig     Json?           // Repayment configuration data
  
  // Transaction tracking
  txHash           String?         // Transaction hash of payment
  blockNumber      Int?            // Block number where payment was confirmed
  blockTimestamp   DateTime?       // Timestamp from blockchain
  
  // Payment flow tracking
  proceedsNotified Boolean         @default(false) // Whether RepaymentEscrow was notified
  distributionComplete Boolean     @default(false) // Whether funds were distributed
  
  // Metadata
  description      String?
  metadata         Json?           // Additional payment-specific data
  
  // Timestamps
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  confirmedAt      DateTime?       // When payment was confirmed on-chain
  
  // Relations
  events           PaymentEvent[]
  indexedEvents    IndexedEvent[] @relation("PaymentEvents")
  
  @@index([status])
  @@index([projectId])
  @@index([payerAddress])
  @@index([txHash])
  @@index([chainId])
  @@index([createdAt])
}

enum PaymentType {
  LIFT_UNIT_PURCHASE    // Direct purchase of lift units
  PROJECT_FUNDING       // Upfront funding for project
  REPAYMENT            // Repayment to funders
  PLATFORM_FEE         // Platform fees
  STEWARD_PAYMENT      // Payment to project stewards
}

enum PaymentStatus {
  PENDING              // Payment initiated but not confirmed
  CONFIRMED            // Payment confirmed on blockchain
  IN_ESCROW           // Payment held in escrow contract
  DISTRIBUTED         // Payment distributed per escrow rules
  FAILED              // Payment failed
  CANCELLED           // Payment cancelled
  REFUNDED            // Payment refunded
}

// Payment events for audit trail
model PaymentEvent {
  id            String       @id @default(cuid())
  
  paymentId     String
  payment       Payment      @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  
  type          PaymentEventType
  
  // Event details
  performedBy   String?      // Address that triggered the event
  amount        String?      // Amount involved in this event
  fromAddress   String?      // Source address (for transfers)
  toAddress     String?      // Destination address (for transfers)
  
  // Blockchain data
  txHash        String?
  blockNumber   Int?
  logIndex      Int?         // Position in transaction logs
  gasUsed       String?
  
  // Event metadata
  notes         String?
  metadata      Json?
  
  createdAt     DateTime     @default(now())
  
  @@index([paymentId])
  @@index([type])
  @@index([txHash])
  @@index([createdAt])
}

enum PaymentEventType {
  PAYMENT_INITIATED       // Payment process started
  PAYMENT_CONFIRMED       // Payment confirmed on blockchain
  ESCROW_DEPOSITED       // Funds deposited to escrow contract
  PROCEEDS_NOTIFIED      // RepaymentEscrow notified of proceeds
  FUNDS_DISTRIBUTED      // Funds distributed from escrow
  PAYMENT_FAILED         // Payment processing failed
  PAYMENT_REFUNDED       // Payment was refunded
}

// Blockchain event indexing
model IndexedEvent {
  id              String      @id @default(cuid())
  
  // Blockchain identification
  chainId         Int
  contractAddress String
  
  // Event identification
  eventName       String      // e.g., "ProceedsReceived", "UnitsSold"
  eventSignature  String      // Event signature hash
  
  // Block information
  blockNumber     Int
  blockHash       String
  blockTimestamp  DateTime
  
  // Transaction information
  txHash          String
  txIndex         Int
  logIndex        Int
  
  // Event data
  topics          Json        // Array of event topics
  data            String      // Raw event data
  decodedArgs     Json        // Decoded event arguments
  
  // Processing status
  processed       Boolean     @default(false)
  processedAt     DateTime?
  
  // Error handling
  processingError String?
  retryCount      Int         @default(0)
  maxRetries      Int         @default(3)
  
  // Relations and metadata
  relatedPaymentId String?    // Link to payment if applicable
  relatedPayment   Payment?   @relation("PaymentEvents", fields: [relatedPaymentId], references: [id])
  
  metadata        Json?
  createdAt       DateTime    @default(now())
  
  @@unique([chainId, txHash, logIndex])
  @@index([chainId, contractAddress])
  @@index([eventName])
  @@index([blockNumber])
  @@index([processed])
  @@index([txHash])
  @@index([createdAt])
}

// Indexer state tracking
model IndexerState {
  id              String      @id @default(cuid())
  
  // Indexer identification
  chainId         Int
  contractAddress String
  indexerType     String      // e.g., "RepaymentEscrow", "AllocationEscrow"
  
  // State tracking
  lastBlockNumber Int         @default(0)
  lastBlockHash   String?
  lastSyncAt      DateTime?
  
  // Configuration
  startBlock      Int         @default(0)
  confirmations   Int         @default(12) // Number of confirmations required
  isActive        Boolean     @default(true)
  
  // Error handling
  errorCount      Int         @default(0)
  lastError       String?
  lastErrorAt     DateTime?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@unique([chainId, contractAddress, indexerType])
  @@index([chainId])
  @@index([isActive])
  @@index([lastSyncAt])
}

// Add payment relation to Project
model ProjectPaymentConfig {
  id                String    @id @default(cuid())
  
  projectId         Int       @unique
  project           Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  // Escrow contract addresses
  allocationEscrow  String?   // AllocationEscrow contract address
  repaymentEscrow   String?   // RepaymentEscrow contract address
  
  // Payment configuration
  acceptsPayments   Boolean   @default(false)
  paymentTokens     Json?     // Array of accepted payment tokens
  
  // Default payment settings
  platformFeeBps    Int?      // Platform fee in basis points
  platformFeeCap    String?   // Maximum platform fee
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
}

// Verification System Models (from migration 20250816132549_verification_system)

enum VerificationStatus {
  PENDING
  IN_REVIEW
  VERIFIED
  REJECTED
  EXPIRED
  REVOKED
}

model VerificationMethod {
  id                Int       @id @default(autoincrement())
  methodId          String    @unique
  name              String
  description       String?
  methodologyType   String
  version           String    @default("1.0")
  criteria          Json
  requiredDataTypes Json?
  minimumConfidence Decimal?  @db.Decimal(5, 4)
  validationPeriod  Int?
  registryContract  String?
  chainId           Int?
  methodHash        String?
  active            Boolean   @default(true)
  isPublic          Boolean   @default(true)
  approvedValidators Json?
  metadata          Json?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  verificationResults VerificationResult[]
  liftUnits          LiftUnit[] @relation("VerificationMethodLiftUnits")
  
  @@index([methodId])
  @@index([methodologyType])
  @@index([active])
  @@index([chainId])
}

model VerificationResult {
  id                Int                @id @default(autoincrement())
  liftUnitId        Int
  methodId          String
  verified          Boolean
  confidenceScore   Decimal?           @db.Decimal(5, 4)
  verificationLevel String?
  evidenceHash      String?
  evidenceIpfsCid   String?
  calculationData   Json?
  validatorAddress  String
  validatorName     String?
  verificationDate  DateTime
  expiryDate        DateTime?
  submittedAt       DateTime           @default(now())
  status            VerificationStatus @default(PENDING)
  notes             String?
  metadata          Json?
  reviewedBy        String?
  reviewedAt        DateTime?
  reviewNotes       String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  // Relations
  liftUnit          LiftUnit           @relation(fields: [liftUnitId], references: [id], onDelete: Cascade)
  method            VerificationMethod @relation(fields: [methodId], references: [methodId], onDelete: Restrict)
  evidenceFiles     EvidenceFile[]
  
  @@index([liftUnitId])
  @@index([methodId])
  @@index([verified])
  @@index([status])
  @@index([verificationDate])
  @@index([validatorAddress])
}

model EvidenceFile {
  id                    Int                @id @default(autoincrement())
  verificationResultId  Int
  evidenceType          String
  fileName              String
  originalFileName      String?
  fileHash              String
  ipfsCid               String?
  fileSize              BigInt
  mimeType              String?
  captureDate           DateTime?
  captureLocation       Json?
  captureDevice         String?
  uploadedBy            String
  uploadedAt            DateTime           @default(now())
  processed             Boolean            @default(false)
  processingError       String?
  verified              Boolean            @default(false)
  verifiedAt            DateTime?
  verificationHash      String?
  metadata              Json?
  createdAt             DateTime           @default(now())
  
  // Relations
  verificationResult    VerificationResult @relation(fields: [verificationResultId], references: [id], onDelete: Cascade)
  
  @@index([verificationResultId])
  @@index([evidenceType])
  @@index([fileHash])
  @@index([ipfsCid])
  @@index([uploadedBy])
  @@index([processed])
}